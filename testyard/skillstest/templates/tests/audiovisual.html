<!DOCTYPE html>
<html>
<head>
<script src='/static/javascript/pageutils.js' type='text/javascript'></script>

<script>

var webrtc_capable = true;
var rtc_peer_connection = null;
var rtc_session_description = null;
var get_user_media = null;
var connect_stream_to_src = null;
var stun_server = "stun.l.google.com:19302";
//var stun_server = "testyard.in:3478";

if (navigator.getUserMedia) { // WebRTC 1.0 standard compliant browser
  if (typeof RTCPeerConnection == 'undefined'){
      rtc_peer_connection = webkitRTCPeerConnection;
  }
  else {
    rtc_peer_connection = RTCPeerConnection;
  }
  rtc_session_description = RTCSessionDescription;
  get_user_media = navigator.getUserMedia.bind(navigator);
  connect_stream_to_src = function(media_stream, media_element) {
    media_element.srcObject = media_stream;
    var isplaying = media_stream.currentTime > 0 && !media_stream.paused && !media_stream.ended && media_stream.readyState > media_stream.HAVE_CURRENT_DATA;
    if(!isplaying){
      try{
        media_element.play();
      }
      catch(err){
        alert("Trying to play");
        media_element.play();
      }
    }
  };
} 
else if (navigator.mozGetUserMedia) { // early firefox webrtc implementation
  rtc_peer_connection = mozRTCPeerConnection;
  rtc_session_description = mozRTCSessionDescription;
  get_user_media = navigator.mozGetUserMedia.bind(navigator);
  connect_stream_to_src = function(media_stream, media_element) {
    media_element.mozSrcObject = media_stream;
    var isplaying = media_stream.currentTime > 0 && !media_stream.paused && !media_stream.ended && media_stream.readyState > media_stream.HAVE_CURRENT_DATA;
    if(!isplaying){
      try{
        media_element.play();
      }
      catch(err){
        alert("Trying to play");
        media_element.play();
      }
    }
  };
 stun_server = "74.125.204.127:19302";
 //stun_server = "13.232.197.1:3478";
} 
else if (navigator.webkitGetUserMedia) { // early webkit webrtc implementation
  rtc_peer_connection = webkitRTCPeerConnection;
  rtc_session_description = RTCSessionDescription;
  get_user_media = navigator.webkitGetUserMedia.bind(navigator);
  connect_stream_to_src = function(media_stream, media_element) {
    media_element.src = webkitURL.createObjectURL(media_stream);
  };
} 
else {
  alert("This browser does not support WebRTC - visit WebRTC.org for more info");
  webrtc_capable = false;
}

</script>
<script>
/*



  The MIT License

  Copyright (c) 2010-2013 Rob Manson, http://buildAR.com. All rights reserved.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.

*/

var call_token; // unique token for this call
var signaling_server; // signaling server for this call
var peer_connection; // peer connection object
var okstatus = false;
var datachannel;
var rchannel;
var callerflag = 0;
var calleeflag = 0;
var file_store = [];
var receivebuffer = [];
var receivedsize = 0;

function sleep(milliseconds) {
  var start = new Date().getTime();
  for (var i = 0; i < 1e7; i++) {
    if ((new Date().getTime() - start) > milliseconds){
      break;
    }
  }
}

// setup stream from the local camera 
function setup_video() {
  get_user_media(
    { 
      "audio": true, // request access to local microphone
      "video": true  // request access to local camera
    }, 
    function (local_stream) { // success callback
      // display preview from the local camera & microphone using local <video> MediaElement
      connect_stream_to_src(local_stream, document.getElementById("local_video"));
      // add local camera stream to peer_connection ready to be sent to the remote peer
      peer_connection.addStream(local_stream);
    },
    log_error
  );
}

// generic error handler
function log_error(error) {
  console.log(error);
}

function enablestartcallbtn(elem){
  if(elem.value.length > 0){
    document.getElementById('stopme').disabled = false;
  }
  else{
    document.getElementById('stopme').disabled = true;
  }
}

function start() {
  peer_connection = new rtc_peer_connection({ // RTCPeerConnection configuration 
    "iceServers": [ 
        { "url": "stun:"+stun_server }, // stun server info
     // { "url": "stun:"+stun_server, 'username' : 'tyuser', 'credentials' : 'typasswd' }, // stun server info
    ]
  });

  // generic handler that sends any ice candidates to the other peer
  peer_connection.onicecandidate = function (ice_event) {
    var token = "{{hashtoken}}";
    call_token = "#"+token;
    if (ice_event.candidate) {
      signaling_server.send(
        JSON.stringify({
          token: call_token,
          type: "new_ice_candidate",
          candidate: ice_event.candidate ,
        })
      );
    }
  };
  scrname = "";
  // If this is the callee/candidate of the interview, then the "Stop Me" button will initially be the "Join Call" button,
  // and the hidden field "joinstatus" will be '0'. Once the "Join Call" button is clicked, the 'joinstatus' will be set to
  // '1' and the call will be answered. Note again: This is for callees only. For callers, the else construct is relevant.
  attendpattern = new RegExp("attend=");
  matchres = attendpattern.exec(document.location);
  if(matchres){
    scrname = document.getElementById('screen_name').value;
    if(document.getElementById('joinstatus').value == '0'){
      document.getElementById('stopme').value = "Join Call";
      document.getElementById('stopme').addEventListener( 'click', function ( event ) {
        document.getElementById('joinstatus').value = '1';
        start();
      }, false);
      return (false);
    }
    else{
      scrname = document.getElementById('screen_name').value;
      if(document.getElementById('joinstatus').value == '1' && scrname.trim() == ""){
        alert("Screen name cannot be empty");
        document.getElementById('joinstatus').value = '0'; // Make it 0 again
        document.getElementById('stopme').value = "Join Call";
        document.getElementById('stopme').addEventListener( 'click', function ( event ) {
          document.getElementById('stopme').value = "Stop Me"
          document.getElementById('stopme').addEventListener( 'click', closewindow, false);
          document.getElementById('joinstatus').value = '1';
          start();
        }, false);
        return (false);
      }
    }
    calleeflag = 1;
  }
  else{ // This is for the caller - "Stop Me" is initially called "Start Call"
    scrname = document.getElementById('screen_name').value;
    if(document.getElementById('joinstatus').value == '0'){
      if(document.getElementById('stopme') !== undefined){
        document.getElementById('stopme').value = "Start Call";
        if(scrname == ""){
          document.getElementById('stopme').disabled = true;
        }
        else{
          document.getElementById('stopme').disabled = false;
        }
        document.getElementById('stopme').addEventListener( 'click', function ( event ) {
          document.getElementById('joinstatus').value = '1';
          start();
        }, false);
      }
      return (false);
    }
    else{
      scrname = document.getElementById('screen_name').value;
      if(document.getElementById('joinstatus').value == '1' && scrname.trim() == ""){
        alert("Screen name cannot be empty");
        document.getElementById('joinstatus').value = '0'; // Make it 0 again
        if(document.getElementById('stopme') !== undefined){
          document.getElementById('stopme').value = "Start Call";
          if(scrname == ""){
            document.getElementById('stopme').disabled = true;
          }
          else{
            document.getElementById('stopme').disabled = false;
          }
          document.getElementById('stopme').addEventListener( 'click', function ( event ) {
            document.getElementById('stopme').value = "Stop Me"
            document.getElementById('stopme').addEventListener( 'click', closewindow, false);
            document.getElementById('joinstatus').value = '1';
            document.getElementById('btnstartcapture').disabled = false;
            start();
          }, false);
        }
        return (false);
      }
    }
    callerflag = 1;
  }
  // display remote video streams when they arrive using local <video> MediaElement
  peer_connection.onaddstream = function (event) {
    if(scrname.trim() != ""){
      connect_stream_to_src(event.stream, document.getElementById("remote_video"));
      // show remote video
      document.getElementById("open_call_state").style.display = "block";
    }
  };

  // setup stream from the local camera 
  if(scrname.trim() != ""){
    setup_video();
    document.getElementById('stopme').value = "Stop Me"
    document.getElementById('stopme').addEventListener( 'click', closewindow, false);
    signaling_server = new WebSocket("wss://{{signal_server}}");
    //signaling_server = new WebSocket("wss://testyard.in:8888");
    if (document.location.hash === "" || document.location.hash === undefined || document.location.hash === "#/") { // you are the Caller
      var token = "{{hashtoken}}";
      call_token = "#"+token;
      document.location.hash = token;
      datachannel = peer_connection.createDataChannel("send_data_channel", {reliable : true}); // Data channel is created by the caller only
      datachannel.onmessage = caller_data_handler;
      signaling_server.onopen = function() {
        signaling_server.onmessage = caller_signal_handler;
        try{
          signaling_server.send(
            JSON.stringify({
              token:call_token,
              type:"join",
              name: scrname
            })
          );
          
          signaling_server.send(
            JSON.stringify({ 
              token:call_token,
              type:"callee_arrived",
              name: scrname
            })
          );
        }
        catch(err){
          return (false);
        }
      }
      document.title = "Calling target... Please wait";
    }
  
    if(matchres){ // This is callee
      call_token = document.location.hash;
      signaling_server.onopen = function() {
        // setup callee signal handler
        signaling_server.onmessage = callee_signal_handler;
        // tell the signaling server you have joined the call 
        try{
          signaling_server.send(
            JSON.stringify({ 
              token:call_token,
              type:"join",
              name: scrname
            })
          ); 

          // let the caller know you have arrived so they can start the call
          signaling_server.send(
            JSON.stringify({ 
              token:call_token,
              type:"callee_arrived",
              name: scrname
            })
          );
        }
        catch(err){
          return (false);
        }
      }
      peer_connection.ondatachannel = receivechannel;

      document.title = "Receiving the call...";
      if(document.captureinterview.btnstartcapture !== undefined){
        document.captureinterview.btnstartcapture.disabled= true;
      }
      //document.captureinterview.btnstopcapture.disabled= true;
    }
  }
  
  if(!(window.File && window.FileReader && window.FileList && window.Blob)){
    document.getElementById('attachlink').style.display = "none";
    document.getElementById('limitmg').innerHTML = "File sharing is not supported on this system";
    document.getElementById('limitmg').style.color = "#aa0000";
  }
  else{ // Initialize file sharing vars and register the event handlers
    document.getElementById('fileattachment').addEventListener("change", attachfiles, false);
    document.getElementById('chatcontrols').addEventListener("dragover", drag_over, false);
    document.getElementById('chatcontrols').addEventListener("drop", attachfiles, false);
  }
}

/* functions used above are defined below */
// Clicking on the file attach link will cause a click to happen on the file input button. 
function click_fileattachment(event){
  document.getElementById('fileattachment').click();
}

function attachfiles(event){
  // Check whether user drag-dropped the files
  event.stopPropagation(); 
  event.preventDefault();
  fileslist = undefined;
  if (event.dataTransfer != undefined && event.dataTransfer.files !== undefined){
    fileslist = event.dataTransfer.files; // User drag-dropped files.
  }
  else{ // User selected the files from the file dialog box.
    fileslist = event.target.files;
  }
  sendprogress = document.getElementById('sendprogressbar');
  if(fileslist.length > 10){
    document.getElementById('limitmsg').innerHTML = "You may upload 10 files only at a time";
    document.getElementById('limitmsg').style.color = "#aa0000";
    return (false);
  }
  maxsize = 25000000; // 25 MB max size allowed
  fsize = 0;
  fnames = "";
  for(var i=0; i < fileslist.length; i++){
    fsize += fileslist[i].size;
    fnames += fileslist[i].name + ",";
  }
  fnames = fnames.replace(/\,$/g, "");
  if(fsize > maxsize){
    document.getElementById('limitmsg').innerHTML = "Size exceeded the max size limit of 25 MB";
    document.getElementById('limitmsg').style.color = "#aa0000";
    return (false);
  }
  // All restrictions have been enforced now. So we will process the files now.
  scrname = document.getElementById('screen_name').value;
  filemessage = "Sending files - " + fnames + "\nTotal Size (KB): " + (fsize/1024).toFixed(1);
  if(callerflag == 1){
    datachannel.send(
      JSON.stringify({
        token: call_token,
        type: "chat_message",
        chatmessage: filemessage,
        name: scrname
      })
    );
  }
  else if(calleeflag == 1){
    rchannel.send(
      JSON.stringify({
        token: call_token,
        type: "chat_message",
        chatmessage: filemessage,
        name: scrname
      })
    );
  }
  // Add this message to the local chat log
  chatmsglog = document.getElementById("chatlogs").innerHTML;
  document.getElementById("chatbox").value = "";
  chatmsglog = chatmsglog.replace("</ul>", "");
  chatmsglogwithoutnl = chatmsglog.replace(/\\n/g, "");
  if(chatmsglogwithoutnl == ""){
    chatmsglog = "<ul>\n";
  }
  chatmsglog += "<li style='color:#0000aa;'>" + filemessage + "</li>\n";
  chatmsglog += "</ul>\n";
  document.getElementById("chatlogs").innerHTML = chatmsglog;
  // Next, we send the files
  idlist = new Array();
  for(var j=0;j < fileslist.length; j++){
    idlist.push(j);
  }
  let offset = 0;
  sendprogress.max = fsize;
  const chunksize = 16384;
  for(var i=0; i < fileslist.length; i++){
    fileobj = fileslist[i];
    id = idlist[i];
    var reader = new FileReader();
    reader.onload = (function (fileobj, id){
      return function(e){
        filesize = fileobj.size;
        sendfile(fileobj.name, id, filesize, e.target.result);
        offset += e.target.result.byteLength;
        sendprogress.value = offset;
        if(offset < fileobj.size){
          readslice(offset);
        }
      }
    })(fileobj, id);
    const readslice = o => {
      if(o + chunksize > fileobj.size){
        const slice = fileobj.slice(offset, fileobj.size);
        reader.readAsArrayBuffer(slice);
      }
      else{
        const slice = fileobj.slice(offset, o + chunksize);
        reader.readAsArrayBuffer(slice);
      }      
    };
    readslice(0);
  } // forloop ends here.
}

function sendfile(fname, fid, fsize, evresult){
  scrname = document.getElementById('screen_name').value;
  if(callerflag == 1){
    datachannel.send(
      JSON.stringify({
        token: call_token,
        type: "file_chunk",
        filechunk: evresult,
        name: scrname,
        filename: fname,
        chunklength: evresult.byteLength,
        filesize: fsize
      })
    );
  }
  else if(calleeflag == 1){
    rchannel.send(
      JSON.stringify({
        token: call_token,
        type: "file_chunk",
        filechunk: evresult,
        name: scrname,
        filename: fname,
        chunklength: evresult.byteLength,
        filesize: fsize
      })
    );
  }
}

function drag_over(event){
  event.stopPropagation();
  event.preventDefault(); // Should not load the file in the window.
}

// handler to process new descriptions
function new_description_created(description) {
  peer_connection.setLocalDescription(
    description, 
    function () {
      signaling_server.send(
        JSON.stringify({
          token:call_token,
          type:"new_description",
          sdp:description,
          chatmessage: ""
        })
      );
    }, 
    log_error
  );
}

// handle signals as a caller
function caller_signal_handler(event) {
  var signal = JSON.parse(event.data);
  if (signal != null && signal.type === "callee_arrived") {
    yn = confirm(signal.name + " has arrived. Allow " + signal.name + " to join the call?");
    if(!yn){ return (False); }
    peer_connection.createOffer(
      new_description_created, 
      log_error
    );
  } 
  else if (signal != null && signal.type === "new_ice_candidate") {
    peer_connection.addIceCandidate(
      new RTCIceCandidate(signal.candidate)
    );
  } 
  else if (signal != null && signal.type === "new_description") {
    peer_connection.setRemoteDescription(
      new rtc_session_description(signal.sdp), 
      function () {
         // extend with own custom answer handling here - Testing.
         //canvasel = document.getElementById('snapshot');
         //canvasel.srcObject = event.stream;
      },
      log_error
    );
    try{
      if (peer_connection.remoteDescription.type == "answer") {
	  connect_stream_to_src(event.stream, document.getElementById("remote_video"));
	  var isplaying = event.stream.currentTime > 0 && !event.stream.paused && !event.stream.ended && event.stream.readyState > event.stream.HAVE_CURRENT_DATA;
	  if(!isplaying){
	    try{
	      document.getElementById("remote_video").play();
	    }
	    catch(err){
	      document.getElementById("remote_video").play(); // Just retry playing it
	    }
	  }
      }
    }
    catch(err){
      console.log(err.message);
    }
  }
  else {
    // extend other signal types here
  }
}

// handle signals as a callee
function callee_signal_handler(event) {
  var signal = JSON.parse(event.data);
  if (signal.type === "new_ice_candidate") {
    peer_connection.addIceCandidate(
      new RTCIceCandidate(signal.candidate)
    );
  } 
  else if (signal.type === "new_description") {
    peer_connection.setRemoteDescription(
      new rtc_session_description(signal.sdp), 
      function () {
        if (peer_connection.remoteDescription.type == "offer") {
          peer_connection.createAnswer(new_description_created, log_error);
        }
      },
      log_error
    );
  }
  else {
    // extend other signal types here
  }
}

function caller_data_handler(event){
  var signal = JSON.parse(event.data);
  if (signal.type === "chat_message"){
    sendername = signal.name;
    chatlogdiv = document.getElementById("chatlogs");
    chatmsglog = chatlogdiv.innerHTML;
    chatmsglog = chatmsglog.replace("</ul>", "");
    chatmsglogwithoutnl = chatmsglog.replace(/\\n/g, "");
    if(chatmsglogwithoutnl == ""){
      chatmsglog = "<ul>\n";
    }
    chatmsglog += "<li style='color:#00aa00;'>" + sendername + ": " + signal.chatmessage + "</li>\n";
    chatmsglog += "</ul>\n";
    chatlogdiv.innerHTML = chatmsglog;
  }
  else if(signal.type === "file_chunk"){
    filename = signal.filename;
    filesize = signal.filesize;
    sendername = signal.name;
    receivebuffer.push(signal.filechunk);
    receivedsize += signal.chunklength;
    if(receivedsize === filesize){ // We have received the entire file.
      const received = new Blob(receivebuffer);
      receivebuffer = [];
      receivedsize = 0;
      href = URL.createObjectURL(received);
      download = filename;
      chatlogdiv = document.getElementById("chatlogs");
      chatmsglog = chatlogdiv.innerHTML;
      chatmsglog = chatmsglog.replace("</ul>", "");
      chatmsglogwithoutnl = chatmsglog.replace(/\\n/g, "");
      if(chatmsglogwithoutnl == ""){
        chatmsglog = "<ul>\n";
      }
      chatmsglog += "<li style='color:#00aa00;'>" + sendername + ": <a href='" + href + "' download='" + download + "'> Click to download '" + filename + "' (" + filesize + " bytes)</a></li>\n";
      chatmsglog += "</ul>\n";
      chatlogdiv.innerHTML = chatmsglog;
    }
  }
}

function receivechannel(event){
  rchannel = event.channel;
  rchannel.onmessage = callee_data_handler;
}

function callee_data_handler(event){
  var signal = JSON.parse(event.data);
  if (signal.type === "chat_message"){
    sendername = signal.name;
    chatlogdiv = document.getElementById("chatlogs");
    chatmsglog = chatlogdiv.innerHTML;
    chatmsglog = chatmsglog.replace("</ul>", "");
    chatmsglogwithoutnl = chatmsglog.replace(/\\n/g, "");
    if(chatmsglogwithoutnl == ""){
      chatmsglog = "<ul>\n";
    }
    chatmsglog += "<li style='color:#00aa00;'>" + sendername + ": " + signal.chatmessage + "</li>\n";
    chatmsglog += "</ul>\n";
    chatlogdiv.innerHTML = chatmsglog;
  }
  else if(signal.type === "file_chunk"){
    filename = signal.filename;
    filesize = signal.filesize;
    sendername = signal.name;
    receivebuffer.push(signal.filechunk);
    receivedsize += signal.chunklength;
    if(receivedsize === filesize){ // We have received the entire file.
      const received = new Blob(receivebuffer);
      receivebuffer = [];
      receivedsize = 0;
      href = URL.createObjectURL(received);
      download = filename;
      chatlogdiv = document.getElementById("chatlogs");
      chatmsglog = chatlogdiv.innerHTML;
      chatmsglog = chatmsglog.replace("</ul>", "");
      chatmsglogwithoutnl = chatmsglog.replace(/\\n/g, "");
      if(chatmsglogwithoutnl == ""){
        chatmsglog = "<ul>\n";
      }
      chatmsglog += "<li style='color:#00aa00;'>" + sendername + ": <a href='" + href + "' download='" + download + "'> Click to download '" + filename + "' (" + filesize + " bytes)</a></li>\n";
      chatmsglog += "</ul>\n";
      chatlogdiv.innerHTML = chatmsglog;
    }
  }
}

function sendchat(){
  chattext = document.getElementById("chatbox").value;
  scrname = document.getElementById("screen_name").value;
  description = peer_connection.setLocalDescription();
  try{
    if(callerflag == 1){
      datachannel.send(
        JSON.stringify({
          token: call_token,
          type: "chat_message",
          chatmessage: chattext,
          name: scrname
        })
      );
    }
    else if(calleeflag == 1){
      rchannel.send(
        JSON.stringify({
          token: call_token,
          type: "chat_message",
          chatmessage: chattext,
          name: scrname
        })
      );
    }
  }
  catch(err){
    console.log(err.message);
  }
  chatmsglog = document.getElementById("chatlogs").innerHTML;
  document.getElementById("chatbox").value = "";
  chatmsglog = chatmsglog.replace("</ul>", "");
  chatmsglogwithoutnl = chatmsglog.replace(/\\n/g, "");
  if(chatmsglogwithoutnl == ""){
    chatmsglog = "<ul>\n";
  }
  chatmsglog += "<li style='color:#0000aa;'>" + chattext + "</li>\n";
  chatmsglog += "</ul>\n";
  document.getElementById("chatlogs").innerHTML = chatmsglog;
}


function sharescreen(){
  //alert("hhhhh");
}

/* https://gist.github.com/Dornhoth/7560fb8ab49dc7cd1ac591839b22d066
 document.getElementById('share-screen').addEventListener('click', async () => {
    if (!displayMediaStream) {
      displayMediaStream = await navigator.mediaDevices.getDisplayMedia();
    }
    connect_stream_to_src(displayMediaStream, document.getElementById("local_video"));
    // add local camera stream to peer_connection ready to be sent to the remote peer
    peer_connection.addStream(displayMediaStream);
    //senders.find(sender => sender.track.kind === 'video').replaceTrack(displayMediaStream.getTracks()[0]);
    
    //hide the share button and display the "stop-sharing" one
    document.getElementById('share-screen').style.display = 'none';
    //document.getElementById('stop-share-screen').style.display = 'inline';
  });
*/
</script>

<style>
.icon {
    width: 50px;
    height: 50px;
    background-repeat: no-repeat;
    background-position: center center;
}
</style>

<script src="static/webaudiovisual/webrtc/RecordRTC.js"></script>
<script src="static/webaudiovisual/webrtc/getScreenId.js"></script>
<script src="static/webaudiovisual/webrtc/gumadapter.js"></script>

<!-- New interface code starts here -->
<link href="//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" rel="stylesheet" id="bootstrap-css">
<script src="//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<!-- New interface code ends here -->

<script>
	    var params = {},r = /([^&=]+)=?([^&]*)/g;
            (function() {
                var params = {},
                    r = /([^&=]+)=?([^&]*)/g;
                function d(s) {
                    return decodeURIComponent(s.replace(/\+/g, ' '));
                }
                var match, search = window.location.search;
                while (match = r.exec(search.substring(1))) {
                    params[d(match[1])] = d(match[2]);
                    if(d(match[2]) === 'true' || d(match[2]) === 'false') {
                        params[d(match[1])] = d(match[2]) === 'true' ? true : false;
                    }
                }
                window.params = params;
            })();
            

            function addStreamStopListener(stream, callback) {
                var streamEndedEvent = 'ended';
                if ('oninactive' in stream) {
                    streamEndedEvent = 'inactive';
                }
                stream.addEventListener(streamEndedEvent, function() {
                    callback();
                    callback = function() {};
                }, false);

                stream.getAudioTracks().forEach(function(track) {
                    track.addEventListener(streamEndedEvent, function() {
                       callback();
                       callback = function() {};
                    }, false);
                });

                stream.getVideoTracks().forEach(function(track) {
                    track.addEventListener(streamEndedEvent, function() {
                        callback();
                        callback = function() {};
                    }, false);
                });
            }
</script>
<script type="text/javascript">
var Base64={_keyStr:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",encode:function(e){var t="";var n,r,i,s,o,u,a;var f=0;e=Base64._utf8_encode(e);while(f<e.length){n=e.charCodeAt(f++);r=e.charCodeAt(f++);i=e.charCodeAt(f++);s=n>>2;o=(n&3)<<4|r>>4;u=(r&15)<<2|i>>6;a=i&63;if(isNaN(r)){u=a=64}else if(isNaN(i)){a=64}t=t+this._keyStr.charAt(s)+this._keyStr.charAt(o)+this._keyStr.charAt(u)+this._keyStr.charAt(a)}return t},decode:function(e){var t="";var n,r,i;var s,o,u,a;var f=0;e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"");while(f<e.length){s=this._keyStr.indexOf(e.charAt(f++));o=this._keyStr.indexOf(e.charAt(f++));u=this._keyStr.indexOf(e.charAt(f++));a=this._keyStr.indexOf(e.charAt(f++));n=s<<2|o>>4;r=(o&15)<<4|u>>2;i=(u&3)<<6|a;t=t+String.fromCharCode(n);if(u!=64){t=t+String.fromCharCode(r)}if(a!=64){t=t+String.fromCharCode(i)}}t=Base64._utf8_decode(t);return t},_utf8_encode:function(e){e=e.replace(/\r\n/g,"\n");var t="";for(var n=0;n<e.length;n++){var r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r)}else if(r>127&&r<2048){t+=String.fromCharCode(r>>6|192);t+=String.fromCharCode(r&63|128)}else{t+=String.fromCharCode(r>>12|224);t+=String.fromCharCode(r>>6&63|128);t+=String.fromCharCode(r&63|128)}}return t},_utf8_decode:function(e){var t="";var n=0;var r=c1=c2=0;while(n<e.length){r=e.charCodeAt(n);if(r<128){t+=String.fromCharCode(r);n++}else if(r>191&&r<224){c2=e.charCodeAt(n+1);t+=String.fromCharCode((r&31)<<6|c2&63);n+=2}else{c2=e.charCodeAt(n+1);c3=e.charCodeAt(n+2);t+=String.fromCharCode((r&15)<<12|(c2&63)<<6|c3&63);n+=3}}return t}};
</script>
<script>
recordingDIV = document.querySelector('.recordrtc');

// This will execute when the user clicks on the button labelled "Start Recording".
// The button will be in this state at the begining of the session, or if the user
// resumes a session after a break.
function startCapture(){
  var recordingPayerlist = document.getElementsByTagName('video');
  
  recordingPlayer = null;
  if (recordingPayerlist.length > 0){
    recordingPlayer = recordingPayerlist[0];
  }
  //var mimeType = 'video/webm';
  var mimeType = 'video/mp4';
  var button = document.captureinterview.btnstartcapture;
  
  if(button.innerHTML == "Start Recording"){
    button.innerHTML = "Stop Recording";
    button.onclick = stopCapture;
  }
  else{ // We are not in appropriate state. So do nothing except for changing the button's face value to "Start Recording".
    button.innerHTML = "Start Recording";
    return;
  }
  var commonConfig = {
    onMediaCaptured: function(stream){
      button.stream = stream;
      msgdiv = document.getElementById('msg');
      msgdiv.innerHTML = "<span style='color: blue;align:center;'>Started Recording...</span>";
      if(button.mediaCapturedCallback) {
        button.mediaCapturedCallback();
      }
    },
    onMediaStopped: function() {
      button.innerHTML = "Start Recording";
    },
    onMediaCapturingFailed: function(err){
      console.log(err);
      alert("Media Capturing Failed: " + err);
    }
  };


function captureAudioPlusVideo(config) {
  captureUserMedia({video: true, audio: true}, function() {
  remote_player = document.getElementById('remote_video');
  audioVideoStream = remote_player.srcObject;
  remote_player.play();
  config.onMediaCaptured(audioVideoStream);
  addStreamStopListener(audioVideoStream, function() {
    config.onMediaStopped();
  });
  }, function(error) {
  config.onMediaCapturingFailed(error);
  });
}


function captureAudio(config) {
  captureUserMedia({audio: true}, function() {
    remote_player = document.getElementById('remote_video');
    audioStream = remote_player.srcObject;
    remote_player.play();
    config.onMediaCaptured(audioStream);
    addStreamStopListener(audioStream, function() {
        config.onMediaStopped();
    });
    }, function(error) {
    config.onMediaCapturingFailed(error);
  });
  canvas = document.getElementById('snapshot');
  takepicture(canvas);
}


function captureUserMedia(mediaConstraints, successCallback, errorCallback) {
  var isBlackBerry = !!(/BB10|BlackBerry/i.test(navigator.userAgent || ''));
  if(isBlackBerry && !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia)) {
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
    navigator.getUserMedia(mediaConstraints, successCallback, errorCallback);
    return;
  }
  navigator.mediaDevices.getUserMedia(mediaConstraints).then(successCallback).catch(errorCallback);
}

  
  captureAudioPlusVideo(commonConfig);
  /*button.mediaCapturedCallback = function(){
    //alert("Type of MediaRecorder: " + typeof MediaRecorder);
    if(typeof MediaRecorder === 'undefined') { // opera or chrome etc.
      button.recordRTC = [];
      //alert("params: " + params.bufferSize);
      if(!params.bufferSize){
         // it fixes audio issues whilst recording 720p
         params.bufferSize = 16384;
      }
      var options = {
        type: 'audio',
        bufferSize: typeof params.bufferSize == 'undefined' ? 0 : parseInt(params.bufferSize),
        sampleRate: typeof params.sampleRate == 'undefined' ? 44100 : parseInt(params.sampleRate),
        leftChannel: params.leftChannel || false,
        disableLogs: params.disableLogs || false,
        recorderType: webrtcDetectedBrowser === 'edge' ? StereoAudioRecorder : null
      };
      if(typeof params.sampleRate == 'undefined') {
        delete options.sampleRate;
      }
      remote_player = document.getElementById('remote_video');
      var audioRecorder = RecordRTC(button.stream, options);
      var videoRecorder = RecordRTC(button.stream,  { type : 'video',
                           disableLogs : params.disableLogs || false,
                           canvas : {
                                   width : params.canvas_width || 320,
                                   height : params.canvas_height || 240
                           },
                           frameInterval : typeof params.frameInterval !== 'undefined' ? parseInt(params.frameInterval) : 20
      });

      videoRecorder.initRecorder(function(){
        audioRecorder.initRecorder(function(){
          audioRecorder.startRecording();
          videoRecorder.startRecording();
        });
      });
      button.recordRTC.push(audioRecorder, videoRecorder);
      alert(audioRecorder);
      button.recordingEndedCallback = function(){
        var audio = new Audio();
        audio.src = audioRecorder.toURL();
        audio.controls = true;
        audio.autoplay = true;

        audio.onloadmetadata = function(){
	  alert("Video Recorder URL: " + videoRecorder.toURL());
          remote_player.src = videoRecorder.toURL();
          remote_player.play();
        };
        remote_player.parentNode.appendChild(document.createElement('hr'));
        remote_player.parentNode.appendChild(audio);
        if (audio.paused) audio.play();
      };
      return;
    }
    
    button.recordRTC = RecordRTC( button.stream, {
      type : 'video',
      mimeType : mimeType,
      disableLogs : params.disableLogs || false,
      getNativeBlobs : true
    });
    
    button.recordingEndedCallback = function (url){
      remote_player.muted = false;
      remote_player.removeAttribute('muted');
      remote_player.src = url;
      remote_player.play();
      remote_player.onended = function(){
        remote_player.pause();
        remote_player.src = URL.createObjectURL(button.recordRTC.blob);
        //alert ("Recording player.src = " + remote_player.src);
      };
    };
  button.recordRTC.startRecording();
};
*/
  
  captureAudio(commonConfig);
  button.mediaCapturedCallback = function() {
        var options = {
            type: 'audio',
            mimeType: mimeType,
            bufferSize: typeof params.bufferSize == 'undefined' ? 0 : parseInt(params.bufferSize),
            sampleRate: typeof params.sampleRate == 'undefined' ? 44100 : parseInt(params.sampleRate),
            leftChannel: params.leftChannel || false,
            disableLogs: params.disableLogs || false,
            recorderType: webrtcDetectedBrowser === 'edge' ? StereoAudioRecorder : null
        };

        if(typeof params.sampleRate == 'undefined') {
            delete options.sampleRate;
        }

        button.recordRTC = RecordRTC(button.stream, options);
        button.recordRTC.startRecording();
    }; // End of button.mediaCapturedCallback...
   
} // Function 'startCapture' ends.


// Function to stop capturing the stream. Additionally, this function is 
// also responsible for uploading the video captured to the server.
function stopCapture(){
  btn = document.captureinterview.btnstartcapture;
  btn.innerHTML = "Start Recording";
  btn.onclick = startCapture;
  function stopStream() {
    if(btn.stream && btn.stream.stop) {
      btn.stream.stop();
      btn.stream = null;
    }
  }
  if(btn.recordRTC){
    if(btn.recordRTC.length){
      btn.recordRTC[0].stopRecording(function(url) {
        var audio = new Audio();
  	audio.src = url;
  	audio.controls = true;
        if(!btn.recordRTC[1]){
	  btn.recordRTC[0].blob = audio;
          btn.recordRTC[0].save("{{interviewfilename}}");
          alert("Saved recording...");
	  //uploadInterviewData(audio, "mp4");
          return;
        }
	else{
          btn.recordRTC[1].stopRecording(function(url) {
	  btn.recordRTC[1].blob = audio;
          btn.recordRTC[1].save("{{interviewfilename}}");
	  alert("Saved recording...");
	  //uploadInterviewData(audio, "mp4");
          });
	}
      }); // end of function(url){...
    }
    else{
      btn.recordRTC.stopRecording(function(url) {
	var audio = new Audio();
  	audio.src = url;
  	audio.controls = true;
	btn.recordRTC.blob = audio;
        btn.recordRTC.save("{{interviewfilename}}");
        alert("Saved recording.");
	//uploadInterviewData(audio, "mp4");
      });
    }
  }
  msgdiv = document.getElementById('msg');
  msgdiv.innerHTML = "";
  return;
}




function clearphoto(canvas) {
    var context = canvas.getContext('2d');
    context.fillStyle = "#AAA";
    context.fillRect(0, 0, canvas.width, canvas.height);

    var data = canvas.toDataURL('image/png');
    photo.setAttribute('src', data);
}


function saveAs(data){
  var download = document.createElement('a');
  download.setAttribute('href', data);
  interviewfname = "{{interviewfilename}}";
  fnameparts = interviewfname.split(".");
  fnameparts.pop();
  fnameparts.push('png');
  imgfname = fnameparts.join(".");
  download.setAttribute('download', imgfname);
  download.click();
}

function closewindow(){
  var resp = confirm("Confirm window close operation");
  if(resp){
    window.close();
  }
}

// The function below facilitates the upload of the image and the 
// audio captured. The first argument is the content (either audio
// or image) and the second argument specifies the type of data
// being uploaded (either "png" or "mp4").
function uploadInterviewData(data, type){
  csrftoken = document.captureinterview.csrfmiddlewaretoken.value;
  var frmdata = new FormData();
  frmdata.append("csrfmiddlewaretoken", csrftoken);
  if(type == "png"){
    interviewfname = "{{interviewfilename}}";
    fnameparts = interviewfname.split(".");
    fnameparts.pop();
    fnameparts.push('png');
    imgfname = fnameparts.join(".");
    //frmdata.append("image", data);
    frmdata.append("image", Base64.encode(data));
    frmdata.append("filename", imgfname);
  }
  else if(type == "mp4"){
    //frmdata.append("audio", data);
    frmdata.append("audio", Base64.encode(data));
    frmdata.append("filename", "{{interviewfilename}}");
  }
  else{ //Unrecognized type element - ignore it.
  }
  frmdata.append('hashtoken', "{{hashtoken}}");
  frmdata.append('interviewlinkid', "{{interviewlinkid}}");
  // Now create an HTTP Post request and send the data to the server
  var xmlhttp;
  if (window.XMLHttpRequest){
    xmlhttp=new XMLHttpRequest();
  }
  else{
    xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
  }
  xmlhttp.onreadystatechange = function(){
  if(xmhttp.readyState == 4){
    if(xmlhttp.readyState == 4 && xmlhttp.status==200){
	upload_record_div = document.getElementById('upload_record');
	upload_record_div.innerHTML = "";
    }
	win = window.open("","evaluationwindow", "width=400, height=600, location=no, menubar=no, scrollbars=yes,toolbar=no,  titlebar=yes, resizable=no, toolbar=no, status=no");
	win.document.write(xmlhttp.responseText);
    }
  }
  xmlhttp.open("POST","{{interview_data_upload_url}}", true);
  xmlhttp.send(frmdata);
  upload_record_div = document.getElementById('upload_record');
  upload_record_div.innerHTML = "<span style='color:#0000AA'>Uploading interview recording data... Please wait!>&nbsp;&nbsp;<img src='static/images/loading_small.gif'></span>"; 
}


function takepicture(canvas) {
    var context = canvas.getContext('2d');
    var video = document.getElementById('remote_video');
    width = 120;
    height = 120;
    if (width && height) {
      canvas.setAttribute('width', width);
      canvas.setAttribute('height', height);
      context.drawImage(video, 0, 0, width, height);
      var data = canvas.toDataURL('image/png');
      photo.setAttribute('src', data);
      saveAs(data);
      //uploadInterviewData(data, "png");
    } 
    else {
      clearphoto(canvas);
    }
}

</script>


<script type="text/css">
.center {
margin: 0 auto;
}
</script>

<style>

@media screen and (min-width: 320px) and (max-width: 480px) { /* mobile phone screens */
  #local_video {
  position: absolute;
  top: 100px;
  left: 200px;
  width: 160px;
  height: 120px;
  background: #333333;
  }
  #remote_video {
  position: absolute;
  top: 100px;
  left: 200px;
  width: 100%;
  height: 50%;
  background: #999999;
  }
}

@media screen and (min-width: 768px) and (max-width: 1200px) { 
html, body {
  padding: 0px;
  margin: 0px;
  font-family: "Arial","Helvetica",sans-serif;
}
#loading_state {
  position: absolute;
  top: 45%;
  left: 0px;
  width: 100%;
  font-size: 20px;
  text-align: center;
}
#open_call_state {
  display:block;
}
#local_video {
  position: absolute;
  top: 100px;
  left: 200px;
  width: 160px;
  height: 120px;
  background: #333333;
}
#remote_video {
  position: absolute;
  top: 100px;
  left: 200px;
  width: 65%;
  height: 70%;
  background: #999999;
}
}
</style>

<style>

.recordrtc button {
    vertical-align: middle;
    line-height: 1;
    padding: 2px 5px;
    height: auto;
    font-size: inherit;
    margin: 0;
}

.video-controls {
  position: absolute;
  left: 200px;
  top: 65px;
  font-weight: bold;
  font-size: inherit;
  white-space: no-wrap;
  vertical-align:bottom;
}

.button {
    display: block;
    width: 165px;
    height: 35px;
    background: #4E9CAF;
    padding-left: 5px;
    padding-right: 5px;
    text-align: center;
    border-radius: 5px;
    color: white;
    font-weight: bold;
    line-height: 25px;
}
</style>
</head>
<body onload="start()" onbeforeunload="stopCapture();"> 
  
  <p style="text-align:center;display:block;background-color:#17a2b8;color:#ffffff;font-size:large;font-weight:bold;height:30px;">TestYard Audiovisual Interview - {{interviewtitle}}</p> 

  <div id="loading_state">
    loading... 
  </div>
  <div id='upload_record'>
  </div>
  <div id='msg'>
  </div>  
  <div id="open_call_state" class="center">
    <div>
    <span class="video-controls">Screen Name:<input type='text' maxlength='20' size='20' placeholder="Screen Name" id="screen_name" name="screen_name" style="position:absolute;left:120px;padding-left:5px;" onkeydown="javascript:enablestartcallbtn(this);">&nbsp;&nbsp;<button id="share-screen" title="Share Screen" style="position:absolute;left:350px;width:30px;height:30px;padding-left:5px;padding-right:5px;" onclick="javascript:sharescreen();"><img src="/static/webrtc/images/screen.svg" style="width:20px;height:20px;"></button><button name='btnstartcapture' id="btnstartcapture" type='button' style="position:absolute;left:400px;height:30px;width:150px;padding-left:10px;background:#ccffff;border:1px solid #00f;radius:4px;" onClick='javascript:startCapture();' disabled>Start Recording</button><input type='button' id="stopme" name= 'stopme' value='Stop Me' style="position:absolute;left:560px;height:30px;padding-left:10px;background:#ffcccc;border:1px solid #f00;radius:4px;"/></span>
   </div>
   <br/>
    <video id="remote_video" controls></video>
    <video id="local_video" controls muted></video>
 </div>
  <br />
  <div align='center'>
  <form name='captureinterview' id='captureinterview' method='POST'>
  
  {% csrf_token %}
  <canvas id='snapshot' style="display:none;"></canvas>
  <br /><br />
  <div class="center">
    <img id="photo" style="display:none;"/>
  </div>
  <fieldset style="position:absolute;border:2px solid #00a;color:#0000aa;background:#ccffff;left:200px;top:95%;width:65%;height:180px;text-align:left;padding-left:20px;vertical-align:bottom;overflow:auto;">
  <legend style="font-weight:bold;font-size:medium;width:11%;">Chat Box</legend>
  <div id="chatlogs">
  <!-- Space for log of chat conversation -->
  </div>
  <div>
  <span  style="padding-bottom:5px;width:100%;" id="chatcontrols"><textarea style="width:95%;background:#fff;border:1px solid #aaa;border-radius:5px;" name='chatbox' id='chatbox' numrows=2 class="form-control"></textarea></span><span style="white-space:nowrap;padding-top:5px;padding-left:15px;padding-right:10px;font-size:small;width:100%;" class="row" id="filesharing"><input type="file" name="fileattachment" id="fileattachment" value="" style="padding-left:10px;padding-right:10px;padding-top:5px;padding-bottom:5px;display:none;" multiple><input type="button" name='chatsend' id='chatsend' value="Send" style="width:100px;color:#ffffff;font-size:small;font-weight:bold;padding-left:5px;padding-right:10px;" class="btn btn-primary" onclick="javascript:sendchat();">&nbsp;&nbsp;<a href="#/" class="button" style="white-space: nowrap;color:#0000aa;font-size:small;text-align:left;padding-left:10px;padding-right:10px;padding-top:5px;padding-bottom:5px;text-align:center;" id="attachlink" onclick="javascript:click_fileattachment();">Click or Drag to Attach</a>&nbsp;&nbsp;<span style="vertical-align:middle;padding-top:8px;" id="limitmsg">Upto 10 files and a max total size limit of 25 MB may be chosen.</span></span><br/>
   <progress id="sendprogressbar" max="0" value="0"></progress>
  </div>
  </fieldset>
    <input type="hidden" name="joinstatus" id="joinstatus" value='0'>
  </form>
  </div>
  <br/><center><hr style="position:absolute;top:140%;width:100%;height:5px;margin-left:auto;margin-right:auto;"></center><br/>
  <footer style="position:absolute;top:150%;left:200px;">
  Footer goes here.
  </footer>
</body>
</html>


